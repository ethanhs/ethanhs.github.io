<!DOCTYPE html>
<html lang="en">

<head>
    <title>Ethan Typing</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://ethanhs.me/style.css">
    <link rel="stylesheet" href="https://ethanhs.me/color/blue.css">

        <link rel="stylesheet" href="https://ethanhs.me/color/background_dark.css">
    
    <link rel="stylesheet" href="https://ethanhs.me/font-hack-subset.css">

    <link rel="me" href="https://hachyderm.io/@ethantyping">
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://ethanhs.me" style="text-decoration: none;">
                    <div class="logo">
                      
                            Ethan&#x27;s Blog
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://ethanhs.me">Home</a></li>
            
                <li><a href="https://ethanhs.me/about/me">About</a></li>
            
                <li><a href="https://ethanhs.me/about/contact">Contact</a></li>
            
                <li><a href="https://github.com/ethanhs" target="_blank" rel="noopener noreferrer">Github</a></li>
            
                <li><a href="https://hachyderm.io/@ethantyping" target="_blank" rel="noopener noreferrer">Mastodon</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://ethanhs.me/typycal/">Typycal - Generate type stubs from runtime type information</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2017-07-26
        </span>

    </div>

    

        
        <div class="post-content">
            <p>EDIT: This project stalled and is no longer being worked on. You can find the sources <a href="https://github.com/ethanhs/typycal">on my github</a>. The original blog is below.</p>
<p>Note: This blog post assumes basic familiarity with typing</p>
<p>I am a collaborator on the <a href="http://mypy-lang.org">mypy</a> project, which implements a static type checker for Python. Static typing is useful for many reasons, such as making refactoring and other code maintenance easier. At PyCon this year, I heard from many developers using mypy who found it useful in understanding their code and finding type errors. Andreas Dewes gave a nice summary and analysis of typing in Python in a <a href="https://www.slideshare.net/japh44/type-annotations-in-python-whats-whys-and-wows">Europython talk</a>. I highly recommend it if you are just starting typing or are not convinced it is worth it to read the slides from that talk.</p>
<p>At the moment, several companies and open source projects have moved to using static typing, such as Dropbox, Google, and <a href="https://zulip.org/">Zulip</a>, an open source chat application. One of the design goals of static typing in Python is to be optional and gradual. However, even with these goals, annotating code, especially for large code bases, can be a significant time drain. With this in mind, I was interested in trying to make it easier for people to adopt typing in their Python code. Some work has been put into making a more advanced type inference tool that would be able to generate useful type information such as Google's <a href="https://github.com/google/pytype">pytype</a> project and mypy's stubgen script. Google and Facebook both have their own closed source runtime type inferencers. However, pytype can be inaccurate and crash on valid code (which is bad if you want to adopt static typing). In addition it only runs on Python 2 (though it can check Python 3 code). Stubgen is rather incomplete, and will likely never be able to infer the most complex cases. These are useful tools, but I believe that runtime introspection can do better.</p>
<p>These solutions seemed overly complex when all the type information needed is right in front of us: in the running code itself! At the time I was thinking about this problem, I coincidentally had been reading up on <a href="https://github.com/Microsoft/Pyjion">Pyjion</a> and <a href="https://www.python.org/dev/peps/pep-0523/">PEP 523: Adding a frame evaluation API to CPython</a> when I realized I could use the new frame evaluation API to do runtime type introspection!</p>
<h2 id="so-what-is-this-frame-evaluation-api">So what is this frame evaluation API?</h2>
<p>The frame evaluation API was introduced mainly for JIT (just in time) compilers, and debuggers (PyCharm uses it). However, I wanted to use it to analyze the types in frames. You may be asking yourself: what is a frame? A frame is a data structure that Python uses to describe scopes and information about that scope. The simplest to understand frame is a function:</p>
<pre data-lang="python" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#569cd6;">def </span><span>test():
</span><span>    </span><span style="color:#569cd6;">...
</span></code></pre>
<p>Modules, functions, generators, and comprehensions have their own scope so they get their own frame. So when I call <code>os.path.abspath</code>(path), I am creating a new frame. The frame data is represented by a C struct in CPython (if you aren't familiar with C, just think of it like a Python class with some attributes). It contains information about the function called, such as its name (<code>abspath</code> in our example), its file path, and most importantly its locals. Locals is a symbol table (a mapping of names to values) for the scope of the frame. For example, in <code>abspath</code>, the <code>path</code> argument is a local. Consider the following:</p>
<pre data-lang="python" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#569cd6;">def </span><span>hello(name):
</span><span>    msg = </span><span style="color:#d69d85;">&quot;Hello </span><span style="color:#b4cea8;">%s</span><span style="color:#d69d85;">!&quot;
</span><span>    print(msg % name)
</span></code></pre>
<p>Both <code>name</code> and <code>msg</code> are locals in the <code>hello</code> frame.</p>
<p>The frame evaluation API allows us to inspect the values of <code>name</code> and <code>msg</code>. The important part of locals is that function arguments are in the locals of a frame. We can get the type of these objects and log the argument types of the frame. Then we can execute the frame (run the Python code) and capture the return value (and type) as well. Thus the full signature of the function for each call is available. Here is basically how the code works (Python equivalent of the C code in typycal).</p>
<pre data-lang="python" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#569cd6;">def </span><span>typycal_evalframe(frame: frameobject, exc: int):
</span><span>    </span><span style="color:#608b4e;">&quot;&quot;&quot;
</span><span style="color:#608b4e;">    frame is the current frame to be executed
</span><span style="color:#608b4e;">    exc indicates whether an exception has been thrown calling the frame.
</span><span style="color:#608b4e;">    &quot;&quot;&quot;
</span><span>    </span><span style="color:#569cd6;">if </span><span>exc:
</span><span>        </span><span style="color:#569cd6;">return </span><span>_PyEval_EvalFrameDefault(frame, exc)  </span><span style="color:#608b4e;"># execute the frame as normal, this function is part of Python&#39;s private C API
</span><span>    </span><span style="color:#569cd6;">else</span><span>:
</span><span>        code = frame.f_code  </span><span style="color:#608b4e;"># this is the bytecode of the frame (stuff to be executed), and some other useful info
</span><span>        name = code.co_name
</span><span>        file_name = code.co_filename
</span><span>        </span><span style="color:#569cd6;">if </span><span>whitelisted(file_name, name):  </span><span style="color:#608b4e;"># ignore stdlib and generators/comprehensions
</span><span>            locals = frame.f_locals  </span><span style="color:#608b4e;"># a dict of locals. names are keys, objects are values
</span><span>            argc = code.co_argcount  </span><span style="color:#608b4e;"># number of arguments passed to the function
</span><span>            ret = _PyEval_EvalFrameDefault(frame, exc)  </span><span style="color:#608b4e;"># run the frame, store the return value for analysis
</span><span>            serialize_types(file_name, name, locals, argc, ret)
</span><span>            </span><span style="color:#569cd6;">return </span><span>ret
</span><span>        </span><span style="color:#569cd6;">else</span><span>:
</span><span>            </span><span style="color:#569cd6;">return </span><span>_PyEval_EvalFrameDefault(frame, exc)  </span><span style="color:#608b4e;"># don&#39;t want to analyze this frame, so execute it as normal
</span><span>
</span><span style="color:#569cd6;">def </span><span>hook():
</span><span>    thread_state = thread_state_get() </span><span style="color:#608b4e;"># Needed to tell Python to run our frame evaluation function, instead of the default
</span><span>    thread_state.interp.eval_frame = typycal_evalframe  </span><span style="color:#608b4e;"># assign our function to be called when a frame needs to be evaluated
</span><span>
</span><span style="color:#569cd6;">def </span><span>unhook():
</span><span>    thread_state = thread_state_get()
</span><span>    thread_state.interp.eval_frame = _PyEval_EvalFrameDefault(frame, exc)
</span></code></pre>
<p>The <code>serialize_types</code> function just takes the Python object and generates PEP 484 compliant type data that is written to a file. You can call the hook from your code:</p>
<pre data-lang="python" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#9b9b9b;">import </span><span>typycal
</span><span>typycal.hook()
</span><span style="color:#569cd6;">... </span><span style="color:#608b4e;"># your code here
</span></code></pre>
<p>The hook will be put in place and typycal will be able to introspect frames, no decorators needed! We now have a means to serialize the type of the current frame! But how to get to *.pyi files?</p>
<h2 id="building-pyi-files">Building *.pyi files</h2>
<p>With this information logged, one can then run a Python program (part of typycal) to analyze the signatures and generate stub files. The hope is that companies and individuals will be able to run typycal on their source via unit tests or other uses, and come out with stubs that are a basis to typing their entire code. Currently typycal is implemented in C++, both to interop with CPython well and to be fast. It is rather unoptimized, and causes the execution of 12 million frames to slow by roughly 5x, which is obviously not ideal. Most of the slowness comes from checking if a frame should be analyzed. To not greatly burden I/O and keep the serialized data as minimal as possible, we want to exclude the standard library, which can add millions of frames to a medium sized code base. I have a few plans to reduce the time spent on I/O and other optimizations in mind.</p>
<p>Since getting type information for all types gets very complex, typycal for now handles <code>int</code>, <code>str</code>, <code>tuple</code>, <code>list</code>, <code>callable</code>s, and <code>None</code>. <code>dict</code> should be relatively straightforward too. All other types will likely be <code>Any</code>'d since they may not be safe to put in a stub. This will likely change with time.</p>
<h2 id="the-future">The future</h2>
<p>I plan on spending the rest of the summer improving typycal to work decently well to the point that I can release it publicly. If you are are interested in getting a look at the library to play with, feel free to contact me, and I will consider sharing it. I also will be discussing this project and static typing in general at PyBay on August 11, and would be happy to answer questions in person.</p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                
                    <span class="button next">
                        <a href="https://ethanhs.me/pybay2017/">
                            <span class="button__text">PyBay 2017</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2024
 Ethan Smith</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
